\section{Исходная программа}


\subsection*{Файл lib1.c}

\begin{lstlisting}[language=C,caption={Ряд Лейбница для и площадь прямоугольника.},captionpos=b]
#include <math.h>

#include "../inc/contract.h"

float Pi(int K) {
    float pi_approx = 0.0f;
    for (int n = 0; n < K; n++) {
        if (n % 2 == 0) {
            pi_approx += 1.0f / (2.0f * n + 1.0f);
        } else {
            pi_approx -= 1.0f / (2.0f * n + 1.0f);
        }
    }
    return 4.0f * pi_approx;
}

float Square(float A, float B) {
    return A * B;
}

\end{lstlisting}

\subsection*{Файл lib2.c}

\begin{lstlisting}[language=C,caption={Формула Валлиса для и площадь прямоугольного треугольника.},captionpos=b]
#include <stdio.h>

#include "../inc/contract.h"


float Pi(int K) {
    if (K <= 0) return 0.0f;
    float pi_half_approx = 1.0f;
    for (int n = 1; n <= K; n++) {
        pi_half_approx *= (2.0f * n) / (2.0f * n - 1.0f);
        pi_half_approx *= (2.0f * n) / (2.0f * n + 1.0f);
    }
    return 2.0f * pi_half_approx;
}

float Square(float A, float B) {
    return 0.5f * A * B;
}

\end{lstlisting}

\subsection*{Файл main\_dynamic.c}

\begin{lstlisting}[language=C,caption={Динамическая загрузка},captionpos=b]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>


typedef float (*Pi_func)(int);
typedef float (*Square_func)(float, float);

void *lib_handle = NULL;
Pi_func pi_func_ptr = NULL;
Square_func square_func_ptr = NULL;
int current_lib = 0; // 0 - not loaded, 1 - lib1, 2 - lib2

const char *LIB_PATH_1 = "./liblib1.so";
const char *LIB_PATH_2 = "./liblib2.so";



int load_library(int lib_id) {
    const char *lib_path = (lib_id == 1) ? LIB_PATH_1 : LIB_PATH_2;

    if (lib_handle != NULL) {
        dlclose(lib_handle);
        lib_handle = NULL;
        pi_func_ptr = NULL;
        square_func_ptr = NULL;
    }

    lib_handle = dlopen(lib_path, RTLD_LAZY);
    if (!lib_handle) {
        fprintf(stderr, "Error load library %s: %s\n", lib_path, dlerror());
        current_lib = 0;
        return 0;
    }

    pi_func_ptr = (Pi_func)dlsym(lib_handle, "Pi");
    if (dlerror() != NULL) {
        fprintf(stderr, "Error to find Pi in %s: %s\n", lib_path, dlerror());
        dlclose(lib_handle);
        lib_handle = NULL;
        current_lib = 0;
        return 0;
    }

    square_func_ptr = (Square_func)dlsym(lib_handle, "Square");
    if (dlerror() != NULL) {
        fprintf(stderr, "Error to find Square in %s: %s\n", lib_path, dlerror());
        dlclose(lib_handle);
        lib_handle = NULL;
        current_lib = 0;
        return 0;
    }

    current_lib = lib_id;
    printf("Success! %d.\n", current_lib);
    return 1;
}

void process_command(int func_id, char* args[]) {
    if (lib_handle == NULL) {
        printf("Library not loaded\n");
        return;
    }

    if (func_id == 1) {
        if (args[0] == NULL) {
            printf("Func 1 need 1 argument(K).\n");
            return;
        }
        int K = atoi(args[0]);
        if (K <= 0) {
            printf("K have to be positive\n");
            return;
        }

  
        float result = pi_func_ptr(K); 
        const char *impl_name = (current_lib == 1) ? "L" : "V";
        printf("Pi(%d) [%s] = %.8f\n", K, impl_name, result);
    }

    else if (func_id == 2) {
        if (args[0] == NULL || args[1] == NULL) {
            printf("Func 2 need 2 arguments\n");
            return;
        }
        float A = atof(args[0]);
        float B = atof(args[1]);
        
        float result = square_func_ptr(A, B);
        const char *impl_name = (current_lib == 1) ? "Rectangle" : "Rect triangle";
        printf("Square(%.2f, %.2f) [%s] = %.2f\n", A, B, impl_name, result);
    } else {
        printf("Unknown.\n");
    }
}

int main() {
    char line[256];
    printf("Commands:\n");
    printf("0 : Realisation swap (1 <-> 2).\n");
    printf("1 arg1...: Pi(K).\n");
    printf("2 arg1 arg2...: Square(A, B).\n");
    
    if (!load_library(1)) {
        fprintf(stderr, "Error to load libraries\n");
        return 1;
    }

    while (1) {
        if (fgets(line, sizeof(line), stdin) == NULL) break;
        
        char *token;
        char *tokens[3] = {NULL, NULL, NULL};
        int token_count = 0;

        token = strtok(line, " \n");
        while (token != NULL && token_count < 3) {
            tokens[token_count++] = token;
            token = strtok(NULL, " \n");
        }
        
        if (token_count == 0 || strcmp(tokens[0], "exit") == 0) break;

        if (token_count >= 1) {
            int command = atoi(tokens[0]);
            
            if (command == 0) {
                int next_lib = (current_lib == 1) ? 2 : 1;
                load_library(next_lib);
            } else {
                process_command(command, &tokens[1]);
            }
        }
    }

    if (lib_handle != NULL) {
        dlclose(lib_handle);
    }
    return 0;
}

\end{lstlisting}

\subsection*{Файл main\_static.c}

\begin{lstlisting}[language=C,caption={Статическая линковка},captionpos=b]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../inc/contract.h"


void process_command(int func_id, char* args[]) {
    if (func_id == 1) {
        if (args[0] == NULL) {
            printf("Error(K).\n");
            return;
        }
        int K = atoi(args[0]);
        if (K <= 0) {
            printf("Error\n");
            return;
        }
        float result = Pi(K);
        printf("Result Pi(%d) = %.8f\n", K, result);
    } 

    else if (func_id == 2) {
        if (args[0] == NULL || args[1] == NULL) {
            printf("Error (A, B).\n");
            return;
        }
        float A = atof(args[0]);
        float B = atof(args[1]);
        
        float result = Square(A, B);
        printf("Square(%.2f, %.2f) = %.2f\n", A, B, result);
    } else {
        printf("Unknown \n");
    }
}

int main() {
    char line[256];
    printf("Realisation 1 (L / Rectangle)\n");

    while (1) {
        printf(">>> ");
        if (fgets(line, sizeof(line), stdin) == NULL) break;
        
        char *token;
        char *tokens[3] = {NULL, NULL, NULL};
        int token_count = 0;

        token = strtok(line, " \n");
        while (token != NULL && token_count < 3) {
            tokens[token_count++] = token;
            token = strtok(NULL, " \n");
        }
        
        if (token_count == 0 || strcmp(tokens[0], "exit") == 0) break;

        if (token_count >= 1) {
            int func_id = atoi(tokens[0]);
            if (func_id != 0) {
                process_command(func_id, &tokens[1]);
            } else {
                printf("Error '0' \n");
            }
        }
    }

    return 0;
}

\end{lstlisting}


\section{Вывод strace}

\subsection*{Для prog1}
\begin{verbatim}
execve("./ipc_program", ["./ipc_program"], 0x7ffcca0c1630 /* 27 vars */) = 0
brk(NULL)                               = 0x5ea37c54b000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x76058ef9f000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=30255, ...}) = 0
mmap(NULL, 30255, PROT_READ, MAP_PRIVATE, 3, 0) = 0x76058ef97000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220\243\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x76058ec00000
mmap(0x76058ec28000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x76058ec28000
mmap(0x76058edb0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x76058edb0000
mmap(0x76058edff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x76058edff000
mmap(0x76058ee05000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x76058ee05000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x76058ef94000
arch_prctl(ARCH_SET_FS, 0x76058ef94740) = 0
set_tid_address(0x76058ef94a10)         = 1482
set_robust_list(0x76058ef94a20, 24)     = 0
rseq(0x76058ef95060, 0x20, 0, 0x53053053) = 0
mprotect(0x76058edff000, 16384, PROT_READ) = 0
mprotect(0x5ea33ed8e000, 4096, PROT_READ) = 0
mprotect(0x76058efd7000, 8192, PROT_READ) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
munmap(0x76058ef97000, 30255)           = 0
write(2, "\320\230\321\201\320\277\320\276\320\273\321\214\320\267\320\276\320\262\320\260\320\275\320\270\320\265: ./ip"..., 53Использование: ./ipc_program input_file
) = 53
exit_group(1)                           = ? 

\end{verbatim}

\subsection*{Для prog2}
\begin{verbatim}
execve("./prog2", ["./prog2"], 0x7ffc688ed910 /* 27 vars */) = 0
brk(NULL)                               = 0x62750638a000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ee77976b000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=30255, ...}) = 0
mmap(NULL, 30255, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ee779763000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220\243\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ee779400000
mmap(0x7ee779428000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7ee779428000
mmap(0x7ee7795b0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x7ee7795b0000
mmap(0x7ee7795ff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x7ee7795ff000
mmap(0x7ee779605000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ee779605000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ee779760000
arch_prctl(ARCH_SET_FS, 0x7ee779760740) = 0
set_tid_address(0x7ee779760a10)         = 9490
set_robust_list(0x7ee779760a20, 24)     = 0
rseq(0x7ee779761060, 0x20, 0, 0x53053053) = 0
mprotect(0x7ee7795ff000, 16384, PROT_READ) = 0
mprotect(0x6274fb7c5000, 4096, PROT_READ) = 0
mprotect(0x7ee7797a3000, 8192, PROT_READ) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
munmap(0x7ee779763000, 30255)           = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
getrandom("\x55\xd2\x7f\xbd\x4f\x65\xd2\xcb", 8, GRND_NONBLOCK) = 8
brk(NULL)                               = 0x62750638a000
brk(0x6275063ab000)                     = 0x6275063ab000
write(1, "\320\232\320\276\320\274\320\260\320\275\320\264\321\213:\n", 16Команды:
) = 16
write(1, "0 : \320\237\320\265\321\200\320\265\320\272\320\273\321\216\321\207\320\265\320\275\320\270\320\265 \321\200\320"..., 610 : Переключение реализации (1 <-> 2).
) = 61
write(1, "1 arg1...: \320\222\321\213\320\267\320\276\320\262 Pi(K).\n", 291 arg1...: Вызов Pi(K).
) = 29
write(1, "2 arg1 arg2...: \320\222\321\213\320\267\320\276\320\262 Squar"..., 412 arg1 arg2...: Вызов Square(A, B).
) = 41
openat(AT_FDCWD, "./liblib1.so", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=15208, ...}) = 0
getcwd("/home/b0rus1a/OSLabs/Lab4", 128) = 26
mmap(NULL, 16400, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ee779766000
mmap(0x7ee779767000, 4096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1000) = 0x7ee779767000
mmap(0x7ee779768000, 4096, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7ee779768000
mmap(0x7ee779769000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7ee779769000
close(3)                                = 0
mprotect(0x7ee779769000, 4096, PROT_READ) = 0
write(1, "\320\243\321\201\320\277\320\265\321\210\320\275\320\276 \320\267\320\260\320\263\321\200\321\203\320\266\320\265\320\275\320"..., 58Успешно загружена Реализация 1.
) = 58
fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
write(1, ">>> ", 4>>> )                     = 4
\end{verbatim}