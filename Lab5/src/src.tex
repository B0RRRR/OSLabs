\section{Метод решения}

Для проверки корректности выполненных лабораторных работ, а также для подтверждения использования предписанных системных вызовов, все разработанные программы были проанализированы с применением утилиты \texttt{strace}. Данная утилита предоставляет возможность отслеживать выполнение системных вызовов в процессе работы программы, фиксируя как передаваемые параметры, так и возвращаемые результаты. \\

Для каждой лабораторной работы формировался отдельный файл трассировки посредством команды следующего вида: \\
\texttt{strace -o trace\_labN.log ./labN\_executable [аргументы]}, \\
где \texttt{trace\_labN.log} — файл с результатами трассировки, а \texttt{labN\_executable} — исполняемый файл, реализующий задание лабораторной работы номер \texttt{N}. \\

Полученные логи подвергались детальному анализу, включающему ручную проверку и элементы автоматизированной обработки, с целью:
\begin{itemize}
    \item идентификации системных вызовов, обязательных в рамках соответствующего задания;
    \item контроля корректности их применения, включая последовательность вызовов, корректную обработку ошибок и допустимость передаваемых аргументов;
    \item подтверждения соответствия фактического поведения программы предполагаемой логике выполнения, включая управление процессами, механизмы синхронизации и обмен данными.
\end{itemize}


\section{Описание Программы}

\subsection*{Анализ системных вызовов лабораторной работы 1}
\begin{enumerate}
    \item \texttt{execve("./parent", ["./parent"], 0x7fff77b42d10) = 0}

    Системный вызов выполняет загрузку и запуск исполняемого файла, полностью заменяя текущий образ процесса.
    \begin{itemize}
        \item \texttt{"./parent"} — путь к исполняемому файлу;
        \item \texttt{["./parent"]} — массив аргументов командной строки (\texttt{argv});
        \item \texttt{0x7fff77b42d10} — указатель на массив переменных окружения (\texttt{envp}).
    \end{itemize}

    \item \texttt{pipe2([3, 4], 0) = 0}

    Создаётся неименованный канал для межпроцессного взаимодействия.
    \begin{itemize}
        \item \texttt{3} — файловый дескриптор конца канала для чтения;
        \item \texttt{4} — файловый дескриптор конца канала для записи;
        \item \texttt{0} — отсутствие флагов (канал создаётся без дополнительных опций).
    \end{itemize}

    \item \texttt{write(1, "Filename:\textbackslash n", 10) = 10}

    Выполняется вывод строки-приглашения пользователю.
    \begin{itemize}
        \item \texttt{1} — стандартный поток вывода (\texttt{stdout});
        \item \texttt{"Filename:\textbackslash n"} — выводимая строка;
        \item \texttt{10} — количество записываемых байт.
    \end{itemize}

    \item \texttt{read(0, "input.txt\textbackslash n", 1024) = 10}

    Осуществляется чтение имени файла из стандартного потока ввода.
    \begin{itemize}
        \item \texttt{0} — стандартный поток ввода (\texttt{stdin});
        \item буфер для сохранения считанных данных;
        \item \texttt{1024} — максимальное число байт для чтения.
    \end{itemize}

    \item \texttt{openat(AT\_FDCWD, "input.txt", O\_RDONLY) = 5}

    Открывается файл для последующего чтения.
    \begin{itemize}
        \item \texttt{AT\_FDCWD} — текущий рабочий каталог;
        \item \texttt{"input.txt"} — имя файла;
        \item \texttt{O\_RDONLY} — режим открытия «только для чтения».
    \end{itemize}
    Файлу присвоен дескриптор \texttt{5}.

    \item \texttt{clone(...) = 6474}

    Создаётся дочерний процесс.
    Аргументы скрыты в трассировке, но включают флаги клонирования и параметры стека.
    Возвращаемое значение \texttt{6474} соответствует идентификатору дочернего процесса.

    \item \texttt{read(3, "Sum: 3354.30\textbackslash n", 4096) = 13}

    Родительский процесс считывает данные из канала.
    \begin{itemize}
        \item \texttt{3} — файловый дескриптор чтения из pipe;
        \item буфер для принимаемых данных;
        \item \texttt{4096} — максимально допустимый размер чтения.
    \end{itemize}

    \item \texttt{write(1, "Sum: 3354.30\textbackslash n", 13) = 13}

    Результат вычислений выводится в стандартный поток вывода.
    \begin{itemize}
        \item \texttt{1} — стандартный вывод;
        \item строка с результатом;
        \item \texttt{13} — длина выводимой строки.
    \end{itemize}

    \item \texttt{--- SIGCHLD ---}

    Родительский процесс получает сигнал \texttt{SIGCHLD}, уведомляющий о завершении дочернего процесса.

    \item \texttt{wait4(-1, NULL, 0, NULL) = 6474}

    Выполняется ожидание завершения дочернего процесса и освобождение его ресурсов.
    \begin{itemize}
        \item \texttt{-1} — ожидание любого дочернего процесса;
        \item \texttt{NULL} — статус завершения не сохраняется;
        \item \texttt{0} — отсутствие дополнительных флагов;
        \item \texttt{NULL} — информация о потреблённых ресурсах не требуется.
    \end{itemize}
    Возвращён идентификатор завершившегося процесса.
\end{enumerate}

\subsection*{Анализ системных вызовов лабораторной работы 2}


\begin{verbatim}
execve("./matrix_filters", ["./matrix_filters", "1000", "1000", "5", "4"], ...)
\end{verbatim}
Системный вызов \texttt{execve} запускает новый процесс.
\begin{itemize}
    \item \texttt{"./matrix\_filters"} — путь к исполняемому файлу.
    \item Массив аргументов:
    \begin{itemize}
        \item \texttt{1000} — число строк матрицы $M$.
        \item \texttt{1000} — число столбцов матрицы $N$.
        \item \texttt{5} — количество повторов фильтрации $K$.
        \item \texttt{4} — максимальное число потоков.
    \end{itemize}
    \item \texttt{...} — указатель на переменные окружения.
\end{itemize}

\begin{verbatim}
brk(NULL)
\end{verbatim}
Вызов \texttt{brk} запрашивает текущее положение границы кучи процесса.
Используется библиотекой \texttt{glibc} для управления динамической памятью.

\begin{verbatim}
mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
\end{verbatim}
Выделение области памяти.
\begin{itemize}
    \item \texttt{NULL} — адрес выбирается ядром автоматически.
    \item \texttt{size} — размер выделяемой области.
    \item \texttt{PROT\_READ | PROT\_WRITE} — разрешено чтение и запись.
    \item \texttt{MAP\_PRIVATE} — изменения видны только процессу.
    \item \texttt{MAP\_ANONYMOUS} — память не связана с файлом.
    \item \texttt{-1, 0} — файловый дескриптор не используется.
\end{itemize}
Данный вызов используется для размещения матриц и служебных структур.

\begin{verbatim}
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC)
\end{verbatim}
Загрузка стандартной библиотеки C.
\begin{itemize}
    \item \texttt{AT\_FDCWD} — путь задан относительно текущего каталога.
    \item \texttt{O\_RDONLY} — файл открыт только для чтения.
    \item \texttt{O\_CLOEXEC} — файл будет закрыт при \texttt{execve}.
\end{itemize}

\begin{verbatim}
mmap(...)
\end{verbatim}
Отображение библиотеки \texttt{libc.so} в адресное пространство процесса.

\begin{verbatim}
clone3({flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|...})
\end{verbatim}
Создание нового потока выполнения.
\begin{itemize}
    \item \texttt{CLONE\_VM} — общая виртуальная память.
    \item \texttt{CLONE\_FS} — общая файловая система.
    \item \texttt{CLONE\_FILES} — общая таблица файловых дескрипторов.
    \item \texttt{CLONE\_SIGHAND} — общие обработчики сигналов.
    \item \texttt{CLONE\_THREAD} — поток в рамках одного процесса.
\end{itemize}
Этот вызов соответствует использованию \texttt{pthread\_create} в программе.

\begin{verbatim}
futex(0x..., FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, tid, NULL, FUTEX_BITSET_MATCH_ANY)
\end{verbatim}
Механизм ожидания завершения потоков.
Используется библиотекой \texttt{pthread} для реализации \texttt{pthread\_join}.

\begin{verbatim}
openat(AT_FDCWD, "results.csv", O_WRONLY|O_CREAT|O_TRUNC, 0666)
\end{verbatim}
Создание файла результатов.
\begin{itemize}
    \item \texttt{O\_WRONLY} — запись в файл.
    \item \texttt{O\_CREAT} — создать файл при отсутствии.
    \item \texttt{O\_TRUNC} — очистить содержимое.
    \item \texttt{0666} — права доступа (rw-rw-rw-).
\end{itemize}

\begin{verbatim}
write(3, "threads,time\n1,0.372066\n...", 46)
\end{verbatim}
Запись результатов измерений в CSV-файл.
\begin{itemize}
    \item \texttt{3} — файловый дескриптор \texttt{results.csv}.
    \item Строка содержит число потоков и измеренное время.
\end{itemize}

\begin{verbatim}
write(1, "Потоков: 1, время: 0.372066 сек", 47)
\end{verbatim}
Вывод информации в стандартный поток вывода (\texttt{stdout}).

\begin{verbatim}
close(3)
\end{verbatim}
Закрытие файла \texttt{results.csv}.

\begin{verbatim}
exit_group(0)
\end{verbatim}
Корректное завершение процесса и всех потоков с кодом возврата 0.


\subsection*{Анализ системных вызовов лабораторной работы 3}

Для анализа работы программы был использован инструмент \texttt{strace}, позволяющий отследить системные вызовы, выполняемые процессом во время запуска и завершения. Ниже приведено пояснение ключевых вызовов, непосредственно связанных с выполнением программы и работой операционной системы.


\texttt{execve("./ipc\_program", ["./ipc\_program"], envp) = 0}

Системный вызов \texttt{execve} загружает исполняемый файл программы \texttt{ipc\_program} в адресное пространство текущего процесса.
\begin{itemize}
    \item первый аргумент — путь к исполняемому файлу;
    \item второй аргумент — массив аргументов командной строки;
    \item третий аргумент — массив переменных окружения.
\end{itemize}
Возврат значения \texttt{0} означает успешный запуск программы.


\texttt{brk(NULL) = 0x5ea37c54b000}

Вызов \texttt{brk} возвращает текущее положение конца сегмента кучи (heap), который используется для динамического выделения памяти.

\texttt{mmap(NULL, 8192, PROT\_READ|PROT\_WRITE, MAP\_PRIVATE|MAP\_ANONYMOUS, -1, 0)}

Выделяется анонимная область виртуальной памяти размером 8192 байта.
\begin{itemize}
    \item \texttt{NULL} — адрес выбирается ядром;
    \item \texttt{8192} — размер отображаемой области;
    \item \texttt{PROT\_READ | PROT\_WRITE} — разрешено чтение и запись;
    \item \texttt{MAP\_PRIVATE | MAP\_ANONYMOUS} — приватное отображение, не связанное с файлом;
    \item \texttt{-1} — файловый дескриптор отсутствует;
    \item \texttt{0} — смещение.
\end{itemize}


\texttt{openat(..., "/lib/x86\_64-linux-gnu/libc.so.6", O\_RDONLY|O\_CLOEXEC)}

Открывается динамическая библиотека \texttt{libc.so.6}, необходимая для выполнения стандартных функций языка C.

\texttt{mmap(..., PROT\_READ|PROT\_EXEC, MAP\_PRIVATE|MAP\_FIXED)}

Библиотека отображается в виртуальную память процесса с правами на чтение и выполнение. Это стандартный этап динамической линковки.

\texttt{mprotect(address, size, PROT\_READ)}

Системный вызов \texttt{mprotect} изменяет права доступа к уже отображённым страницам памяти, запрещая запись и повышая безопасность выполнения программы.

\texttt{write(2, "...Использование: ./ipc\_program input\_file", 53)}

Выполняется вывод диагностического сообщения в стандартный поток ошибок.
\begin{itemize}
    \item \texttt{2} — файловый дескриптор stderr;
    \item строка — сообщение об ошибке использования программы;
    \item \texttt{53} — количество записанных байт.
\end{itemize}

\texttt{exit\_group(1)}

Завершение процесса и всех его потоков с кодом возврата \texttt{1}, что указывает на ошибочное завершение программы.

\section{Анализ системных вызовов лабораторной работы 4}

Анализ вывода утилиты \texttt{strace} позволяет наглядно увидеть различия в механизмах загрузки динамических библиотек между Программой №1 (Ранняя линковка) и Программой №2 (Поздняя линковка).

\subsection*{Случай №1: Программа с Ранней Линковкой (\texttt{./ipc\_program})}

\subsection{Этап 1: Запуск и инициализация процесса}

Процесс начинается с системных вызовов, подготавливающих среду выполнения и адресное пространство.

\texttt{execve("./prog1", ["./prog1"], ...)} --- инициализирует выполнение программы. Ядро загружает исполняемый файл в память и передает управление динамическому загрузчику.
\texttt{brk(NULL)} --- программа запрашивает адрес конца сегмента данных. Это необходимо для последующего управления динамической памятью (кучей).
\texttt{mmap(NULL, 8192, PROT\_READ|PROT\_WRITE, ...)} --- выделение анонимной памяти для системных нужд (буферов ввода-вывода или служебных структур библиотек).


\subsection{Этап 2: Поиск и отображение библиотек}

Ключевое отличие ранней линковки заключается в том, что загрузчик (\texttt{ld-linux.so}) ищет зависимости, указанные в заголовке ELF-файла, до начала выполнения функции \texttt{main}.

\begin{itemize}
    \item \texttt{openat(AT\_FDCWD, "liblib1.so", O\_RDONLY|O\_CLOEXEC) = 3} --- загрузчик находит и открывает файл пользовательской библиотеки. \texttt{3} --- файловый дескриптор открытого файла.
    \item \texttt{read(3, "\textbackslash 177ELF...", 832)} --- чтение заголовка ELF для проверки архитектуры и корректности библиотеки.
    \item \texttt{mmap(NULL, 16400, PROT\_READ, ..., 3, 0)} --- резервирование виртуального адресного пространства под всю библиотеку.
    \item \texttt{mmap(..., PROT\_READ|PROT\_EXEC, ..., 3, 0x1000)} --- отображение секции кода библиотеки. Флаг \texttt{PROT\_EXEC} разрешает процессору выполнять инструкции в этой области памяти.
    \item \texttt{close(3)} --- закрытие файла библиотеки после завершения его отображения (\texttt{mapping}) в память.
\end{itemize}



\subsection{Этап 3: Загрузка стандартной библиотеки C}

После пользовательских библиотек загружаются системные зависимости, такие как \texttt{libc.so.6}.

\begin{itemize}
    \item \texttt{openat(..., "/etc/ld.so.cache", ...)} --- использование системного кэша для быстрого поиска пути к стандартным библиотекам.
    \item \texttt{openat(..., "/lib/x86\_64-linux-gnu/libc.so.6", ...)} --- открытие основной библиотеки языка C, содержащей функции \texttt{printf}, \texttt{fgets} и др.
\end{itemize}

\subsection{Этап 4: Настройка защиты и выполнение}

Перед передачей управления пользователю, система выполняет финальные настройки безопасности.

\begin{itemize}
    \item \texttt{mprotect(..., PROT\_READ)} --- перевод таблиц глобальных смещений (GOT) в режим "только чтение" для предотвращения атак на переполнение буфера.
    \item \texttt{arch\_prctl(ARCH\_SET\_FS, ...)} --- установка сегментного регистра для реализации локального хранилища потока (TLS).
\end{itemize}



\subsection{Этап 5: Пользовательский ввод-вывод}

Только после завершения всех этапов линковки мы видим системные вызовы, инициированные непосредственно кодом в \texttt{main.c}.

\begin{itemize}
    \item \texttt{write(1, "Используется Реализация 1...", 103)} --- вывод приветственного сообщения в стандартный поток вывода (\texttt{stdout}, дескриптор 1).
    \item \texttt{read(0, ...)} --- программа вызывает блокирующий системный вызов для чтения из стандартного ввода (\texttt{stdin}, дескриптор 0), ожидая команды пользователя.
\end{itemize}


\subsection*{Случай №2: Программа с Поздней Линковкой (\texttt{./prog2})}

Вывод \texttt{strace} для \texttt{prog2} демонстрирует ключевое отличие: использование \texttt{dlopen} для загрузки пользовательской библиотеки, что подтверждает механизм поздней линковки.

\begin{lstlisting}[language=C, caption={Фрагмент strace для ./prog2}]
execve("./prog2", ["./prog2"], ...) = 0
openat(AT_FDCWD, "/etc/ld.so.cache", ...) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", ...) = 3
[...]
munmap(0x7ee779763000, 30255) = 0
write(1, "\320\232\320\276\320\274\320\260\320\275\320\264\321\213:\n", 16) = 16
openat(AT_FDCWD, "./liblib1.so", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0755, st_size=15208, ...}) = 0
mmap(NULL, 16400, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ee779766000
mmap(0x7ee779767000, 4096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1000) = 0x7ee779767000
close(3) = 0
write(1, "\320\243\321\201\320\277\320\265\321\210\320\275\320\276 \320\267\320\260\320\263\321\200\321\203\320\266\320\265\320\275\320"..., 58) = 58
\end{lstlisting}

\textbf{Ключевые вызовы поздней линковки:}
\begin{itemize}
    \item \texttt{openat(AT\_FDCWD, "./liblib1.so", O\_RDONLY|O\_CLOEXEC) = 3}: Вызов соответствует вызову \texttt{dlopen(".\/liblib1.so", ...)} в коде \texttt{main\_dynamic.c}. Программа сама инициирует открытие файла библиотеки. Возврат \texttt{3} — это файловый дескриптор.
    \item \texttt{mmap(NULL, 16400, PROT\_READ, MAP\_PRIVATE|MAP\_DENYWRITE, 3, 0) = 0x7ee779766000}: Библиотека \texttt{liblib1.so} проецируется (\texttt{mmap}) в память процесса. Аргумент \texttt{3} здесь — это файловый дескриптор, полученный от предыдущего \texttt{openat}.
    \item \texttt{close(3) = 0}: Файловый дескриптор, открытый для библиотеки, немедленно закрывается после того, как ее содержимое проецировано в память.
    \item \texttt{write(1, "\320\243\321\201\320\277\320\265\321\210\320\275\320\276 \320\267\320\260\320\263..."...)}: Вывод сообщения "Успешно загружена Реализация 1.", которое генерируется кодом сразу после успешного вызова \texttt{dlopen}.
\end{itemize}


